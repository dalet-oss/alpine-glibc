name: 'Package APKs'

on:
  workflow_dispatch:
  push:
    branches:
      - master
    paths:
      - .github/workflows/package-apks.yml
      - glibc-versions.yml
      - glibc/*.tar.gz

concurrency:
  group: '${{ github.workflow }} @ ${{ github.event.pull_request.head.label || github.head_ref || github.ref }}'
  cancel-in-progress: false


jobs:

  discover-versions:
    runs-on: ubuntu-latest
    outputs:
      versions: ${{ steps.discover-versions.outputs.versions }}
      versions_json: ${{ steps.discover-versions.outputs.versions_json }}
    steps:
      - uses: actions/checkout@v4
      - name: Discover versions
        id: discover-versions
        run: |
          VERSIONS=$(cat glibc-versions.yml | yq '.versions[].glibcVersion')
          VERSIONS_JSON=$(echo ${VERSIONS} | jq  -Rc 'split(" ")')
          echo versions=${VERSIONS} > ${GITHUB_OUTPUT}
          echo versions_json=${VERSIONS_JSON} >> ${GITHUB_OUTPUT}


  find-unpackaged-version:
    needs: discover-versions
    runs-on: ubuntu-latest
    env:
      VERSIONS: ${{ needs.discover-versions.outputs.versions }}
    outputs:
      packaging_required: ${{ steps.find.outputs.packaging_required }}
      sha512: ${{ steps.find.outputs.sha512 }}
    steps:

      - name: Checkout
        uses: actions/checkout@v4
        with:
          lfs: true

      - id: find
        name: Find the first unpackaged version (if any exists)
        run: |
          for VERSION in ${VERSIONS[@]}; do \
            BASE_APK_FILENAME="./apk/amd64/${VERSION}/glibc-${VERSION}.apk"; \
            GLIBC_TARBALL="./glibc/glibc-bin-${VERSION}-x86_64.tar.gz"; \
            if [ -f "${BASE_APK_FILENAME}" ]; then \
              echo "Version ${VERSION} already exists in ${BASE_APK_FILENAME}"; \
            else \
              SHA512=$(cat glibc-versions.yml | yq '(.versions[] | select(.glibcVersion == "'"${VERSION}"'") | .amd64sha512sum)'); \
              echo "Version ${VERSION} with sha512sum '${SHA512}' has not been packaged yet" && \
              if [ ! -f "${GLIBC_TARBALL}" ]; then \
                echo "Source ${GLIBC_TARBALL} is not available - bombing out here until compile-glibc workflows have all been resolved and PRs merged" && false
              fi
              echo "packaging_required=${VERSION}" > ${GITHUB_OUTPUT} && \
              echo "sha512=${SHA512}" >> ${GITHUB_OUTPUT} && \
              break; \
            fi; \
          done


  package-apk:
    needs: find-unpackaged-version
    if: needs.find-unpackaged-version.outputs.packaging_required != ''
    runs-on: ubuntu-latest
    permissions:
      contents: write
      pull-requests: write
    env:
      VERSION: ${{ needs.find-unpackaged-version.outputs.packaging_required }}
      FILENAME: glibc/glibc-bin-${{ needs.find-unpackaged-version.outputs.packaging_required }}-x86_64.tar.gz
      SHA512: ${{ needs.find-unpackaged-version.outputs.sha512 }}
    steps:

      - name: Checkout
        uses: actions/checkout@v4
        with:
          lfs: true

      - name: Ensure output directories are present; add dummy apk file for arm64
        run: |
          mkdir -p apk/amd64/${VERSION}
          mkdir -p apk/arm64/${VERSION}
          touch apk/arm64/${VERSION}/glibc-dummy-${VERSION}.apk

      - name: Template APKBUILD for the version we're operating on
        run: |
          cp -v APKBUILD.tmpl APKBUILD
          sed -i.bak -e "s/VERSION/${VERSION}/g" APKBUILD
          sed -i.bak -e "s/SHA512SUM/${SHA512}/g" APKBUILD
          rm APKBUILD.bak

      - name: Provision alpine-packaging-rsa key from Github secret, with permissions for the alpine-abuild container to read it
        env:
          # The keypair itself was generated by running the following command:
          #     ssh-keygen -t rsa -b 4096 -m PEM -f alpine-packaging-rsa -N "" -C "Dalet-OSS Alpine glibc signing key"
          #     openssl rsa -in alpine-packaging-rsa -pubout > alpine-packaging-rsa.pub
          # The `alpine-packaging-rsa.pub` file was checked in directly to the root of this repo; the private key was
          # added as a Github secret.
          ALPINE_PACKAGING_RSA_PRIVATE_KEY: ${{ secrets.ALPINE_PACKAGING_RSA_PRIVATE_KEY }}
        run: |
          echo "${ALPINE_PACKAGING_RSA_PRIVATE_KEY}" > alpine-packaging-rsa
          chmod 444 alpine-packaging-rsa

        # See https://github.com/sgerrand/alpine-pkg-glibc/blob/main/.circleci/config.yml for
        # what we're doing here
      - name: Create Docker volumes
        run: |
          docker create --name input --volume /home/builder/package alpine:3.23 /bin/true
          docker cp . input:/home/builder/package/
          docker create --name output --volume /packages alpine:3.23 /bin/true
          docker cp alpine-packaging-rsa.pub output:/packages/

      - name: Build Alpine packages
        run: |
          docker run --rm \
            --env PACKAGER_PRIVKEY='/home/builder/.abuild/alpine-packaging-rsa' \
            --volumes-from input \
            --volumes-from output \
            --volume "${{ github.workspace }}/alpine-packaging-rsa:/home/builder/.abuild/alpine-packaging-rsa" \
            --volume "${{ github.workspace }}/alpine-packaging-rsa.pub:/home/builder/.abuild/alpine-packaging-rsa.pub" \
            --volume "${{ github.workspace }}/alpine-packaging-rsa.pub:/etc/apk/keys/alpine-packaging-rsa.pub" \
            sgerrand/alpine-abuild:3.20

      - name: Extract packages
        run: |
          mkdir -p packages
          docker cp output:/packages/builder packages/

      - name: Remove Docker volumes
        run: |
          docker rm input output

      - name: Move built packages into their final locations; git add
        env:
          PACKAGE_BUILD_OUTPUT_DIR: packages/builder/x86_64
          LOCAL_APK_DIR: apk/amd64/${{ env.VERSION }}
          PACKAGE_BUILD_VERSION: ${{ env.VERSION }}-r0
        run: |
          ls -l ${PACKAGE_BUILD_OUTPUT_DIR}/
          mv ${PACKAGE_BUILD_OUTPUT_DIR}/glibc-${PACKAGE_BUILD_VERSION}.apk      ${LOCAL_APK_DIR}/glibc-${VERSION}.apk
          mv ${PACKAGE_BUILD_OUTPUT_DIR}/glibc-bin-${PACKAGE_BUILD_VERSION}.apk  ${LOCAL_APK_DIR}/glibc-bin-${VERSION}.apk
          mv ${PACKAGE_BUILD_OUTPUT_DIR}/glibc-i18n-${PACKAGE_BUILD_VERSION}.apk ${LOCAL_APK_DIR}/glibc-i18n-${VERSION}.apk
          ls -l ${LOCAL_APK_DIR}
          rm -rf packages
          git add apk/amd64/${VERSION}/glibc*-${VERSION}.apk apk/arm64/${VERSION}/glibc-dummy-${VERSION}.apk

      - name: Test APK installation, including signature validation
        run: |
          docker run --rm \
            --volume "${{ github.workspace }}/alpine-packaging-rsa.pub:/etc/apk/keys/alpine-packaging-rsa.pub" \
            --volume "${{ github.workspace }}/apk/amd64/${VERSION}:/packages" \
            alpine:3.23 \
            sh -c 'apk -U add --no-progress --upgrade /packages/*.apk && ls -l /usr/glibc-compat/lib && ls -l /lib64 && ls -l /lib64/ld-linux-x86-64.so.2 | grep glibc'; \

      - name: Submit new APKs via PR
        uses: peter-evans/create-pull-request@v6
        with:
          title: "Add APKs for glibc ${{ env.VERSION }}, packaged and signed by Github Actions"
          branch: "autogenerated-apks-for-glibc-${{ env.VERSION }}"
          body: |
            Automated PR to add the binary APK packages for glibc version ${{ env.VERSION }}.
          labels: automated
          commit-message: "Add APKs for glibc ${{ env.VERSION }}, packaged and signed by Github Actions"


  verify-apk-installations:
    needs:
      - discover-versions
      - find-unpackaged-version
    if: needs.find-unpackaged-version.outputs.packaging_required == ''
    runs-on: ubuntu-latest
    env:
      VERSIONS: ${{ needs.discover-versions.outputs.versions }}
    steps:

      - name: Checkout
        uses: actions/checkout@v4
        with:
          lfs: true

      - name: Test APK installation for all versions, including signature validation
        run: |
          for VERSION in ${VERSIONS[@]}; do \
            docker run --rm \
              --volume "${{ github.workspace }}/alpine-packaging-rsa.pub:/etc/apk/keys/alpine-packaging-rsa.pub" \
              --volume "${{ github.workspace }}/apk/amd64/${VERSION}:/packages" \
              alpine:3.23 \
              sh -c 'apk -U add --no-progress --upgrade /packages/*.apk && ls -l /usr/glibc-compat/lib && ls -l /lib64 && ls -l /lib64/ld-linux-x86-64.so.2 | grep glibc'; \
          done


  publish-releases:
    needs:
      - discover-versions
      - find-unpackaged-version
    if: needs.find-unpackaged-version.outputs.packaging_required == '' && false # temporarily disabled while investigating the possibility of introducing ARM64 support
    runs-on: ubuntu-latest
    strategy:
      matrix:
        version: ${{ fromJson(needs.discover-versions.outputs.versions_json) }}
    steps:

      - id: check-release
        name: Check if release exists
        env:
          GH_TOKEN: ${{ secrets.GITHUB_TOKEN }}
        run: |
          if gh release view "v${{ matrix.version }}" &>/dev/null; then
            echo "exists=true" >> "$GITHUB_OUTPUT"
          else
            echo "exists=false" >> "$GITHUB_OUTPUT"
          fi

      - name: Create Release
        if: steps.check-release.outputs.exists == 'false'
        uses: softprops/action-gh-release@v2
        with:
          tag_name: "${{ matrix.version }}-r0"
          name: "${{ matrix.version }}-r0"
          body: |
            Version ${{ matrix.version }} of the GNU C library, glibc.
          files: |
            apk/amd64/${{ matrix.version }}/glibc*-${{ matrix.version }}.apk
          token: ${{ secrets.GITHUB_TOKEN }}
